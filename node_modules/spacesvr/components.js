import { useLoader, useThree, useFrame, useUpdate } from 'react-three-fiber';
import { TextureLoader, Vector3, AudioListener, PositionalAudio, Color, PMREMGenerator, UnsignedByteType, Vector2, MeshStandardMaterial, DoubleSide, FontLoader, VideoTexture, LinearFilter, RGBFormat, ClampToEdgeWrapping } from 'three';
import { useContext, createContext, useRef, useEffect, useState, useMemo, Suspense } from 'react';
import { useGLTF } from '@react-three/drei';
import { PositionalAudioHelper } from 'three/examples/jsm/helpers/PositionalAudioHelper';
import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader';
import { usePlane } from '@react-three/cannon';
import ShopifyBuy from 'shopify-buy';
import _extends from '@babel/runtime/helpers/esm/extends';

const IMAGE_SRC = "https://d27rt3a60hh1lx.cloudfront.net/images/whiteArrow.png";
const IMAGE_SRC_DARK = "https://d27rt3a60hh1lx.cloudfront.net/images/blackArrow.png";
const Arrow = props => {
  const {
    dark,
    ...restProps
  } = props;
  const texture = useLoader(TextureLoader, dark ? IMAGE_SRC_DARK : IMAGE_SRC);
  return /*#__PURE__*/React.createElement("group", restProps, /*#__PURE__*/React.createElement("mesh", {
    scale: [0.004, 0.004, 0.004]
  }, /*#__PURE__*/React.createElement("planeBufferGeometry", {
    attach: "geometry",
    args: [98, 51]
  }), /*#__PURE__*/React.createElement("meshStandardMaterial", {
    map: texture,
    attach: "material",
    alphaTest: 0.5,
    transparent: true,
    normalMap: texture
  })));
};

const environmentStateContext = /*#__PURE__*/createContext({});
function useEnvironment() {
  return useContext(environmentStateContext);
}

const Audio = props => {
  const {
    url,
    position = new Vector3(0, 0, 0),
    dCone,
    rollOff = 1,
    volume = 7,
    helper
  } = props;
  const {
    paused,
    container
  } = useEnvironment();
  const audioRef = useRef();
  const speaker = useRef();
  const {
    camera,
    scene
  } = useThree();
  const listener = useRef();
  useEffect(() => {
    if (container && !audioRef.current) {
      const audio = document.createElement("audio");
      audio.src = url;
      audio.autoplay = false;
      audio.preload = "auto";
      audio.crossOrigin = "anonymous";
      audio.loop = true;
      container == null ? void 0 : container.appendChild(audio);
      audioRef.current = audio;
      return () => {
        audio.pause();

        if (listener.current) {
          camera.remove(listener.current);
        }
      };
    }
  }, [container, audioRef.current]); // audio

  useEffect(() => {
    if (!paused && camera && audioRef.current && !speaker.current) {
      listener.current = new AudioListener();
      camera.add(listener.current);
      speaker.current = new PositionalAudio(listener.current);
      speaker.current.setMediaElementSource(audioRef.current);
      speaker.current.position.copy(position);

      if (dCone) {
        speaker.current.setDirectionalCone(dCone.x, dCone.y, dCone.z);
      }

      speaker.current.setRolloffFactor(rollOff);
      speaker.current.setVolume(volume);

      if (helper) {
        const helper = new PositionalAudioHelper(speaker.current);
        speaker.current.add(helper);
      }

      scene.add(speaker.current);
    }
  }, [audioRef.current, camera, speaker.current, listener.current, paused]);
  useEffect(() => {
    if (!paused && audioRef.current && audioRef.current.paused) {
      audioRef.current.play();
    }
  }, [paused, audioRef.current]);
  return /*#__PURE__*/React.createElement(React.Fragment, null);
};

const Background = props => {
  const {
    color
  } = props;
  const {
    scene
  } = useThree();
  const [setup, setSetup] = useState(false);
  useEffect(() => {
    if (scene && !setup) {
      scene.background = new Color(color);
      setSetup(true);
    }
  }, [scene, setup]);
  return null;
};

const HDRI = props => {
  const {
    src
  } = props;
  const {
    gl,
    scene
  } = useThree(); // pmrem generator for hdri loading

  const pmremGenerator = new PMREMGenerator(gl);
  pmremGenerator.compileEquirectangularShader(); // actual file loader

  const loader = new RGBELoader();
  loader.setDataType(UnsignedByteType);
  useEffect(() => {
    loader.load(src, texture => {
      const envMap = pmremGenerator.fromEquirectangular(texture).texture; // sent envmap onto scene env and background

      scene.environment = envMap;
      scene.background = envMap;
      texture.dispose();
      pmremGenerator.dispose();
    });
  }, [scene, loader, pmremGenerator]);
  return null;
};

const frameWidth = 0.3;
const frameDepth = 0.1;
const borderThickness = 0.2;
const borderDepth = 0.2;
const meshOffset = 0.0005;
const Image = props => {
  const {
    src,
    sizeScale,
    ratio,
    framed,
    doubleSided,
    material: passedMaterial,
    color = 0x111111
  } = props;
  const texture = useLoader(TextureLoader, src);
  const group = useRef();
  const image = useRef(); // sizing

  const normalizedRatio = new Vector2(ratio[0], ratio[1]).normalize();
  const width = normalizedRatio.x * sizeScale;
  const height = normalizedRatio.y * sizeScale;
  const material = useMemo(() => passedMaterial || new MeshStandardMaterial({
    color: color,
    roughness: 0.8,
    metalness: 0.05
  }), []);
  return /*#__PURE__*/React.createElement("group", props, /*#__PURE__*/React.createElement("group", {
    ref: group
  }, /*#__PURE__*/React.createElement("mesh", {
    castShadow: true,
    ref: image
  }, /*#__PURE__*/React.createElement("planeBufferGeometry", {
    attach: "geometry",
    args: [width, height]
  }), /*#__PURE__*/React.createElement("meshStandardMaterial", {
    attach: "material",
    map: texture,
    side: doubleSided ? DoubleSide : undefined
  })), framed && /*#__PURE__*/React.createElement(React.Fragment, null, !doubleSided && /*#__PURE__*/React.createElement("mesh", {
    "position-z": [-0.1 - meshOffset],
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [width + frameWidth, height + frameWidth, frameDepth]
  })), /*#__PURE__*/React.createElement("mesh", {
    "position-y": height / 2 + frameWidth / 2 - borderThickness / 2,
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [width + frameWidth, borderThickness, borderDepth]
  })), /*#__PURE__*/React.createElement("mesh", {
    "position-y": -height / 2 - frameWidth / 2 + borderThickness / 2,
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [width + frameWidth, borderThickness, borderDepth]
  })), /*#__PURE__*/React.createElement("mesh", {
    "position-x": -width / 2 - frameWidth / 2 + borderThickness / 2,
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [borderThickness, height + frameWidth, borderDepth]
  })), /*#__PURE__*/React.createElement("mesh", {
    "position-x": width / 2 + frameWidth / 2 - borderThickness / 2,
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [borderThickness, height + frameWidth, borderDepth]
  })))));
};

const InfinitePlane = props => {
  const {
    height,
    size = [100, 100],
    visible
  } = props;
  const [ref] = usePlane(() => ({
    rotation: [-Math.PI / 2, 0, 0],
    position: [0, height, 0],
    args: size,
    type: "Static"
  }));
  return /*#__PURE__*/React.createElement("mesh", {
    ref: ref
  }, visible && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("planeBufferGeometry", {
    attach: "geometry",
    args: size
  }), /*#__PURE__*/React.createElement("meshPhongMaterial", {
    attach: "material",
    color: "#660000"
  })));
};

const SPEED = 0.2;
const FILE_URL = "https://d27rt3a60hh1lx.cloudfront.net/models/SpacesSphere1/SpacesSphere1.glb";
const Logo = props => {
  const {
    rotating,
    floating,
    ...restProps
  } = props;
  const group = useRef();
  const sphereGroup = useRef();
  const {
    nodes,
    materials
  } = useGLTF(FILE_URL);
  useFrame(({
    clock
  }) => {
    if (group.current && rotating) {
      group.current.rotation.y = clock.getElapsedTime() * SPEED;
    }

    if (group.current && floating) {
      group.current.position.y = 0.1 * 2 * Math.sin(clock.getElapsedTime() * SPEED * 2);
    }
  });
  return /*#__PURE__*/React.createElement("group", restProps, /*#__PURE__*/React.createElement("group", {
    ref: group
  }, /*#__PURE__*/React.createElement(Suspense, {
    fallback: null
  }, /*#__PURE__*/React.createElement("group", {
    ref: sphereGroup,
    scale: [100, 100, 100],
    dispose: null
  }, /*#__PURE__*/React.createElement("group", {
    position: [0, 0, 0]
  }, /*#__PURE__*/React.createElement("mesh", {
    material: materials.Sphere,
    geometry: nodes.Sphere.geometry,
    castShadow: true
  }))))));
};
useGLTF.preload(FILE_URL);

const useShopify = props => {
  const {
    domain,
    token
  } = props;
  const client = ShopifyBuy.buildClient({
    domain: domain,
    storefrontAccessToken: token
  });
  const [products, setProducts] = useState();
  const [checkout, setCheckout] = useState();
  const [checkoutOpen, setCheckoutOpen] = useState("false");
  useEffect(() => {
    if (!products && !checkout) {
      client.product.fetchAll() // @ts-ignore
      .then(shopifyProducts => setProducts(shopifyProducts));
      client.checkout.create() // @ts-ignore
      .then(shopifyCheckout => setCheckout(shopifyCheckout));
    }
  }, [products, checkout]);
  return {
    client,
    products,
    checkout,
    setCheckout,
    checkoutOpen,
    setCheckoutOpen
  };
};

/**
 *
 * Interactible adds on click and hover methods to any group of Object3D's
 *
 * @param props
 * @constructor
 */
const Interactable = props => {
  const {
    children,
    onClick,
    onHover,
    onUnHover
  } = props;
  const {
    player
  } = useEnvironment();
  const {
    raycaster
  } = player;
  const group = useRef();
  const [hovered, setHovered] = useState(false);
  useFrame(() => {
    if (group.current && raycaster) {
      const intersections = raycaster.intersectObject(group.current, true);

      if (intersections && intersections.length > 0) {
        if (!hovered) {
          setHovered(true);

          if (onHover) {
            onHover();
          }
        }
      } else if (hovered) {
        setHovered(false);

        if (onUnHover) {
          onUnHover();
        }
      }
    }
  });
  useEffect(() => {
    const checkClick = () => {
      if (hovered && onClick) {
        onClick();
      }
    };

    document.addEventListener("click", checkClick);
    return () => {
      document.removeEventListener("click", checkClick);
    };
  }, [hovered, onClick]);
  return /*#__PURE__*/React.createElement("group", {
    ref: group
  }, children);
};

const Shop = props => {
  const {
    domain,
    token,
    localProducts,
    itemSize = 4,
    itemRatio = [1, 1],
    spaceBetween = 9,
    position = [-9, 4, 0],
    rotation = [0, Math.PI / 9, 0]
  } = props;
  const productImages = [];
  let positionOffset = 0;
  let offset = 0;

  if (localProducts) {
    for (const product of localProducts) {
      const productImage = /*#__PURE__*/React.createElement(Interactable, {
        onClick: () => window.location.href = product[1],
        key: product[0]
      }, /*#__PURE__*/React.createElement(Image, {
        src: product[0],
        ratio: itemRatio,
        sizeScale: itemSize,
        position: [Math.cos(offset) * 19 + spaceBetween, 2, Math.sin(offset) * 19],
        rotation: [0, Math.PI / 2 - offset + Math.PI, 0],
        framed: true
      }));
      productImages.push(productImage);
      offset += 2 * Math.PI / localProducts.length;
      positionOffset++;
    }

    return /*#__PURE__*/React.createElement("group", {
      position: position,
      rotation: rotation
    }, productImages);
  }

  let shopifyState;

  if (domain && token) {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    shopifyState = useShopify({
      domain: domain,
      token: token
    });
  } // @ts-ignore


  const {
    products
  } = shopifyState;

  if (products) {
    // @ts-ignore
    products.forEach(product => {
      if (product.images[0]) {
        const src = product.images[0].src;
        const productImage = /*#__PURE__*/React.createElement(Image, {
          src: src,
          ratio: itemRatio,
          sizeScale: itemSize,
          position: [spaceBetween * positionOffset, 2, 0],
          rotation: [0, Math.PI, 0],
          framed: true
        });
        productImages.push(productImage);
        positionOffset++;
      }
    });
  }

  return /*#__PURE__*/React.createElement("group", {
    position: position,
    rotation: rotation
  }, productImages);
};

const FONT_FILE = "fonts/Couture_Bold.json";
const Text = props => {
  const {
    text,
    vAlign = "center",
    hAlign = "center",
    size = 1,
    bevel = false,
    color = "#000000",
    font: fontFile,
    material,
    ...restProps
  } = props;
  const font = useLoader(FontLoader, fontFile || FONT_FILE);
  const config = useMemo(() => ({
    font,
    size,
    height: 0.75 * size,
    curveSegments: 32,
    bevelEnabled: bevel,
    bevelThickness: 0.15 * size,
    bevelSize: 0.0625 * size,
    bevelOffset: 0,
    bevelSegments: 8
  }), [font]);
  const mesh = useUpdate(self => {
    const size = new Vector3();
    self.geometry.computeBoundingBox();
    self.geometry.boundingBox.getSize(size);
    self.position.x = hAlign === "center" ? -size.x / 2 : hAlign === "right" ? 0 : -size.x;
    self.position.y = vAlign === "center" ? -size.y / 2 : vAlign === "top" ? 0 : -size.y;
  }, [text]);
  return /*#__PURE__*/React.createElement("group", _extends({}, restProps, {
    scale: [0.1 * size, 0.1 * size, 0.1]
  }), /*#__PURE__*/React.createElement("mesh", {
    ref: mesh,
    material: material
  }, /*#__PURE__*/React.createElement("textGeometry", {
    attach: "geometry",
    args: [text, config]
  }), !material && /*#__PURE__*/React.createElement("meshPhongMaterial", {
    attach: "material",
    color: color,
    reflectivity: 30
  })));
};

const frameWidth$1 = 0.3;
const frameDepth$1 = 0.1;
const borderThickness$1 = 0.2;
const borderDepth$1 = 0.2;
const meshOffset$1 = 0.0005;
const Video = props => {
  const {
    src,
    sizeScale,
    ratio,
    framed,
    position,
    rotation,
    muted,
    doubleSided
  } = props;
  const {
    camera,
    scene
  } = useThree();
  const {
    container,
    paused
  } = useEnvironment();
  const group = useRef(); // video state

  const videoRef = useRef();
  const textureRef = useRef();
  const [texReady, setTexReady] = useState(false); // audio refs

  const listener = useRef();
  const speaker = useRef();
  useFrame(() => {
    var _videoRef$current;

    if (!texReady && (videoRef == null ? void 0 : videoRef.current) && (videoRef == null ? void 0 : (_videoRef$current = videoRef.current) == null ? void 0 : _videoRef$current.currentTime) > 0) {
      setTexReady(true);
    }
  });
  const material = useMemo(() => new MeshStandardMaterial({
    color: 0x111111,
    roughness: 0.8,
    metalness: 0.05
  }), []); // sizing

  const normalizedRatio = new Vector2(ratio[0], ratio[1]).normalize();
  const width = normalizedRatio.x * sizeScale;
  const height = normalizedRatio.y * sizeScale; // video textures use effect

  useEffect(() => {
    if (container && !videoRef.current) {
      // build video dom element
      const video = document.createElement("video");
      const source = document.createElement("source");
      source.src = src;
      video.loop = true; //@ts-ignore

      video.playsInline = true;
      video.crossOrigin = "anonymous";
      video.preload = "auto";
      video.autoplay = false;
      video.muted = muted || false;
      video.style.position = "absolute";
      video.style.opacity = "0";
      video.style.pointerEvents = "none";
      video.style.visibility = "hidden"; // add to parent container

      container.appendChild(video);
      video.appendChild(source); // create video texture

      const texture = new VideoTexture(video);
      texture.minFilter = LinearFilter;
      texture.magFilter = LinearFilter;
      texture.format = RGBFormat;
      texture.matrixAutoUpdate = false;
      texture.wrapS = ClampToEdgeWrapping;
      texture.wrapT = ClampToEdgeWrapping;
      videoRef.current = video;
      textureRef.current = texture;
      return () => {
        video.pause();
        video.remove();
        videoRef.current = undefined;
        texture.dispose();
        textureRef.current = undefined;

        if (speaker.current) {
          speaker.current.disconnect();
          speaker.current = undefined;
        }

        if (listener.current) {
          camera.remove(listener.current);
        }

        setTexReady(false);
      };
    }
  }, [container, videoRef == null ? void 0 : videoRef.current]); // audio useeffect

  useEffect(() => {
    if (!muted && !paused && camera && videoRef.current && !speaker.current) {
      listener.current = new AudioListener();
      camera.add(listener.current);
      speaker.current = new PositionalAudio(listener.current);
      speaker.current.setMediaElementSource(videoRef.current);
      speaker.current.setRefDistance(0.75);
      speaker.current.setRolloffFactor(1);
      speaker.current.setVolume(1);
      speaker.current.setDirectionalCone(180, 230, 0.1);

      if (position) {
        // @ts-ignore due to bad types, it's an array though
        speaker.current.position.set(position[0], position[1], position[2]);
      }

      if (rotation) {
        // @ts-ignore due to bad types, it's an array though
        speaker.current.rotation.set(rotation[0], rotation[1], rotation[2]);
      }

      scene.add(speaker.current);
    }
  }, [videoRef.current, camera, speaker.current, listener.current, paused]); // play video if player closes menu

  useEffect(() => {
    if (!paused && videoRef.current && videoRef.current.paused) {
      videoRef.current.play();
    }
  }, [paused]);
  return /*#__PURE__*/React.createElement("group", props, /*#__PURE__*/React.createElement("group", {
    ref: group
  }, texReady && /*#__PURE__*/React.createElement("mesh", null, /*#__PURE__*/React.createElement("planeBufferGeometry", {
    attach: "geometry",
    args: [width, height]
  }), /*#__PURE__*/React.createElement("meshStandardMaterial", {
    attach: "material",
    map: textureRef.current,
    side: doubleSided ? DoubleSide : undefined
  })), framed && /*#__PURE__*/React.createElement(React.Fragment, null, !doubleSided && /*#__PURE__*/React.createElement("mesh", {
    "position-z": [-0.1 - meshOffset$1],
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [width + frameWidth$1, height + frameWidth$1, frameDepth$1]
  })), /*#__PURE__*/React.createElement("mesh", {
    "position-y": height / 2 + frameWidth$1 / 2 - borderThickness$1 / 2,
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [width + frameWidth$1, borderThickness$1, borderDepth$1]
  })), /*#__PURE__*/React.createElement("mesh", {
    "position-y": -height / 2 - frameWidth$1 / 2 + borderThickness$1 / 2,
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [width + frameWidth$1, borderThickness$1, borderDepth$1]
  })), /*#__PURE__*/React.createElement("mesh", {
    "position-x": -width / 2 - frameWidth$1 / 2 + borderThickness$1 / 2,
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [borderThickness$1, height + frameWidth$1, borderDepth$1]
  })), /*#__PURE__*/React.createElement("mesh", {
    "position-x": width / 2 + frameWidth$1 / 2 - borderThickness$1 / 2,
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [borderThickness$1, height + frameWidth$1, borderDepth$1]
  })))));
};

export { Arrow, Audio, Background, HDRI, Image, InfinitePlane, Logo, Shop, Text, Video };
import React from "react";