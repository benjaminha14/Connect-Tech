'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectWithoutPropertiesLoose = require('@babel/runtime/helpers/objectWithoutPropertiesLoose');
var reactThreeFiber = require('react-three-fiber');
var THREE = require('three');
var react = require('react');
var drei = require('@react-three/drei');
var PositionalAudioHelper = require('three/examples/jsm/helpers/PositionalAudioHelper');
var RGBELoader = require('three/examples/jsm/loaders/RGBELoader');
var cannon = require('@react-three/cannon');
var ShopifyBuy = require('shopify-buy');
var _extends = require('@babel/runtime/helpers/extends');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _objectWithoutPropertiesLoose__default = /*#__PURE__*/_interopDefaultLegacy(_objectWithoutPropertiesLoose);
var ShopifyBuy__default = /*#__PURE__*/_interopDefaultLegacy(ShopifyBuy);
var _extends__default = /*#__PURE__*/_interopDefaultLegacy(_extends);

var IMAGE_SRC = "https://d27rt3a60hh1lx.cloudfront.net/images/whiteArrow.png";
var IMAGE_SRC_DARK = "https://d27rt3a60hh1lx.cloudfront.net/images/blackArrow.png";
var Arrow = function Arrow(props) {
  var dark = props.dark,
      restProps = _objectWithoutPropertiesLoose__default['default'](props, ["dark"]);

  var texture = reactThreeFiber.useLoader(THREE.TextureLoader, dark ? IMAGE_SRC_DARK : IMAGE_SRC);
  return /*#__PURE__*/React.createElement("group", restProps, /*#__PURE__*/React.createElement("mesh", {
    scale: [0.004, 0.004, 0.004]
  }, /*#__PURE__*/React.createElement("planeBufferGeometry", {
    attach: "geometry",
    args: [98, 51]
  }), /*#__PURE__*/React.createElement("meshStandardMaterial", {
    map: texture,
    attach: "material",
    alphaTest: 0.5,
    transparent: true,
    normalMap: texture
  })));
};

var environmentStateContext = /*#__PURE__*/react.createContext({});
function useEnvironment() {
  return react.useContext(environmentStateContext);
}

var Audio = function Audio(props) {
  var url = props.url,
      _props$position = props.position,
      position = _props$position === void 0 ? new THREE.Vector3(0, 0, 0) : _props$position,
      dCone = props.dCone,
      _props$rollOff = props.rollOff,
      rollOff = _props$rollOff === void 0 ? 1 : _props$rollOff,
      _props$volume = props.volume,
      volume = _props$volume === void 0 ? 7 : _props$volume,
      helper = props.helper;

  var _useEnvironment = useEnvironment(),
      paused = _useEnvironment.paused,
      container = _useEnvironment.container;

  var audioRef = react.useRef();
  var speaker = react.useRef();

  var _useThree = reactThreeFiber.useThree(),
      camera = _useThree.camera,
      scene = _useThree.scene;

  var listener = react.useRef();
  react.useEffect(function () {
    if (container && !audioRef.current) {
      var audio = document.createElement("audio");
      audio.src = url;
      audio.autoplay = false;
      audio.preload = "auto";
      audio.crossOrigin = "anonymous";
      audio.loop = true;
      container == null ? void 0 : container.appendChild(audio);
      audioRef.current = audio;
      return function () {
        audio.pause();

        if (listener.current) {
          camera.remove(listener.current);
        }
      };
    }
  }, [container, audioRef.current]); // audio

  react.useEffect(function () {
    if (!paused && camera && audioRef.current && !speaker.current) {
      listener.current = new THREE.AudioListener();
      camera.add(listener.current);
      speaker.current = new THREE.PositionalAudio(listener.current);
      speaker.current.setMediaElementSource(audioRef.current);
      speaker.current.position.copy(position);

      if (dCone) {
        speaker.current.setDirectionalCone(dCone.x, dCone.y, dCone.z);
      }

      speaker.current.setRolloffFactor(rollOff);
      speaker.current.setVolume(volume);

      if (helper) {
        var _helper = new PositionalAudioHelper.PositionalAudioHelper(speaker.current);

        speaker.current.add(_helper);
      }

      scene.add(speaker.current);
    }
  }, [audioRef.current, camera, speaker.current, listener.current, paused]);
  react.useEffect(function () {
    if (!paused && audioRef.current && audioRef.current.paused) {
      audioRef.current.play();
    }
  }, [paused, audioRef.current]);
  return /*#__PURE__*/React.createElement(React.Fragment, null);
};

var Background = function Background(props) {
  var color = props.color;

  var _useThree = reactThreeFiber.useThree(),
      scene = _useThree.scene;

  var _useState = react.useState(false),
      setup = _useState[0],
      setSetup = _useState[1];

  react.useEffect(function () {
    if (scene && !setup) {
      scene.background = new THREE.Color(color);
      setSetup(true);
    }
  }, [scene, setup]);
  return null;
};

var HDRI = function HDRI(props) {
  var src = props.src;

  var _useThree = reactThreeFiber.useThree(),
      gl = _useThree.gl,
      scene = _useThree.scene; // pmrem generator for hdri loading


  var pmremGenerator = new THREE.PMREMGenerator(gl);
  pmremGenerator.compileEquirectangularShader(); // actual file loader

  var loader = new RGBELoader.RGBELoader();
  loader.setDataType(THREE.UnsignedByteType);
  react.useEffect(function () {
    loader.load(src, function (texture) {
      var envMap = pmremGenerator.fromEquirectangular(texture).texture; // sent envmap onto scene env and background

      scene.environment = envMap;
      scene.background = envMap;
      texture.dispose();
      pmremGenerator.dispose();
    });
  }, [scene, loader, pmremGenerator]);
  return null;
};

var frameWidth = 0.3;
var frameDepth = 0.1;
var borderThickness = 0.2;
var borderDepth = 0.2;
var meshOffset = 0.0005;
var Image = function Image(props) {
  var src = props.src,
      sizeScale = props.sizeScale,
      ratio = props.ratio,
      framed = props.framed,
      doubleSided = props.doubleSided,
      passedMaterial = props.material,
      _props$color = props.color,
      color = _props$color === void 0 ? 0x111111 : _props$color;
  var texture = reactThreeFiber.useLoader(THREE.TextureLoader, src);
  var group = react.useRef();
  var image = react.useRef(); // sizing

  var normalizedRatio = new THREE.Vector2(ratio[0], ratio[1]).normalize();
  var width = normalizedRatio.x * sizeScale;
  var height = normalizedRatio.y * sizeScale;
  var material = react.useMemo(function () {
    return passedMaterial || new THREE.MeshStandardMaterial({
      color: color,
      roughness: 0.8,
      metalness: 0.05
    });
  }, []);
  return /*#__PURE__*/React.createElement("group", props, /*#__PURE__*/React.createElement("group", {
    ref: group
  }, /*#__PURE__*/React.createElement("mesh", {
    castShadow: true,
    ref: image
  }, /*#__PURE__*/React.createElement("planeBufferGeometry", {
    attach: "geometry",
    args: [width, height]
  }), /*#__PURE__*/React.createElement("meshStandardMaterial", {
    attach: "material",
    map: texture,
    side: doubleSided ? THREE.DoubleSide : undefined
  })), framed && /*#__PURE__*/React.createElement(React.Fragment, null, !doubleSided && /*#__PURE__*/React.createElement("mesh", {
    "position-z": [-0.1 - meshOffset],
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [width + frameWidth, height + frameWidth, frameDepth]
  })), /*#__PURE__*/React.createElement("mesh", {
    "position-y": height / 2 + frameWidth / 2 - borderThickness / 2,
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [width + frameWidth, borderThickness, borderDepth]
  })), /*#__PURE__*/React.createElement("mesh", {
    "position-y": -height / 2 - frameWidth / 2 + borderThickness / 2,
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [width + frameWidth, borderThickness, borderDepth]
  })), /*#__PURE__*/React.createElement("mesh", {
    "position-x": -width / 2 - frameWidth / 2 + borderThickness / 2,
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [borderThickness, height + frameWidth, borderDepth]
  })), /*#__PURE__*/React.createElement("mesh", {
    "position-x": width / 2 + frameWidth / 2 - borderThickness / 2,
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [borderThickness, height + frameWidth, borderDepth]
  })))));
};

var InfinitePlane = function InfinitePlane(props) {
  var height = props.height,
      _props$size = props.size,
      size = _props$size === void 0 ? [100, 100] : _props$size,
      visible = props.visible;

  var _usePlane = cannon.usePlane(function () {
    return {
      rotation: [-Math.PI / 2, 0, 0],
      position: [0, height, 0],
      args: size,
      type: "Static"
    };
  }),
      ref = _usePlane[0];

  return /*#__PURE__*/React.createElement("mesh", {
    ref: ref
  }, visible && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("planeBufferGeometry", {
    attach: "geometry",
    args: size
  }), /*#__PURE__*/React.createElement("meshPhongMaterial", {
    attach: "material",
    color: "#660000"
  })));
};

var SPEED = 0.2;
var FILE_URL = "https://d27rt3a60hh1lx.cloudfront.net/models/SpacesSphere1/SpacesSphere1.glb";
var Logo = function Logo(props) {
  var rotating = props.rotating,
      floating = props.floating,
      restProps = _objectWithoutPropertiesLoose__default['default'](props, ["rotating", "floating"]);

  var group = react.useRef();
  var sphereGroup = react.useRef();

  var _ref = drei.useGLTF(FILE_URL),
      nodes = _ref.nodes,
      materials = _ref.materials;

  reactThreeFiber.useFrame(function (_ref2) {
    var clock = _ref2.clock;

    if (group.current && rotating) {
      group.current.rotation.y = clock.getElapsedTime() * SPEED;
    }

    if (group.current && floating) {
      group.current.position.y = 0.1 * 2 * Math.sin(clock.getElapsedTime() * SPEED * 2);
    }
  });
  return /*#__PURE__*/React.createElement("group", restProps, /*#__PURE__*/React.createElement("group", {
    ref: group
  }, /*#__PURE__*/React.createElement(react.Suspense, {
    fallback: null
  }, /*#__PURE__*/React.createElement("group", {
    ref: sphereGroup,
    scale: [100, 100, 100],
    dispose: null
  }, /*#__PURE__*/React.createElement("group", {
    position: [0, 0, 0]
  }, /*#__PURE__*/React.createElement("mesh", {
    material: materials.Sphere,
    geometry: nodes.Sphere.geometry,
    castShadow: true
  }))))));
};
drei.useGLTF.preload(FILE_URL);

var useShopify = function useShopify(props) {
  var domain = props.domain,
      token = props.token;
  var client = ShopifyBuy__default['default'].buildClient({
    domain: domain,
    storefrontAccessToken: token
  });

  var _useState = react.useState(),
      products = _useState[0],
      setProducts = _useState[1];

  var _useState2 = react.useState(),
      checkout = _useState2[0],
      setCheckout = _useState2[1];

  var _useState3 = react.useState("false"),
      checkoutOpen = _useState3[0],
      setCheckoutOpen = _useState3[1];

  react.useEffect(function () {
    if (!products && !checkout) {
      client.product.fetchAll() // @ts-ignore
      .then(function (shopifyProducts) {
        return setProducts(shopifyProducts);
      });
      client.checkout.create() // @ts-ignore
      .then(function (shopifyCheckout) {
        return setCheckout(shopifyCheckout);
      });
    }
  }, [products, checkout]);
  return {
    client: client,
    products: products,
    checkout: checkout,
    setCheckout: setCheckout,
    checkoutOpen: checkoutOpen,
    setCheckoutOpen: setCheckoutOpen
  };
};

/**
 *
 * Interactible adds on click and hover methods to any group of Object3D's
 *
 * @param props
 * @constructor
 */
var Interactable = function Interactable(props) {
  var children = props.children,
      onClick = props.onClick,
      onHover = props.onHover,
      onUnHover = props.onUnHover;

  var _useEnvironment = useEnvironment(),
      player = _useEnvironment.player;

  var raycaster = player.raycaster;
  var group = react.useRef();

  var _useState = react.useState(false),
      hovered = _useState[0],
      setHovered = _useState[1];

  reactThreeFiber.useFrame(function () {
    if (group.current && raycaster) {
      var intersections = raycaster.intersectObject(group.current, true);

      if (intersections && intersections.length > 0) {
        if (!hovered) {
          setHovered(true);

          if (onHover) {
            onHover();
          }
        }
      } else if (hovered) {
        setHovered(false);

        if (onUnHover) {
          onUnHover();
        }
      }
    }
  });
  react.useEffect(function () {
    var checkClick = function checkClick() {
      if (hovered && onClick) {
        onClick();
      }
    };

    document.addEventListener("click", checkClick);
    return function () {
      document.removeEventListener("click", checkClick);
    };
  }, [hovered, onClick]);
  return /*#__PURE__*/React.createElement("group", {
    ref: group
  }, children);
};

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var Shop = function Shop(props) {
  var domain = props.domain,
      token = props.token,
      localProducts = props.localProducts,
      _props$itemSize = props.itemSize,
      itemSize = _props$itemSize === void 0 ? 4 : _props$itemSize,
      _props$itemRatio = props.itemRatio,
      itemRatio = _props$itemRatio === void 0 ? [1, 1] : _props$itemRatio,
      _props$spaceBetween = props.spaceBetween,
      spaceBetween = _props$spaceBetween === void 0 ? 9 : _props$spaceBetween,
      _props$position = props.position,
      position = _props$position === void 0 ? [-9, 4, 0] : _props$position,
      _props$rotation = props.rotation,
      rotation = _props$rotation === void 0 ? [0, Math.PI / 9, 0] : _props$rotation;
  var productImages = [];
  var positionOffset = 0;
  var offset = 0;

  if (localProducts) {
    var _loop = function _loop() {
      var product = _step.value;
      var productImage = /*#__PURE__*/React.createElement(Interactable, {
        onClick: function onClick() {
          return window.location.href = product[1];
        },
        key: product[0]
      }, /*#__PURE__*/React.createElement(Image, {
        src: product[0],
        ratio: itemRatio,
        sizeScale: itemSize,
        position: [Math.cos(offset) * 19 + spaceBetween, 2, Math.sin(offset) * 19],
        rotation: [0, Math.PI / 2 - offset + Math.PI, 0],
        framed: true
      }));
      productImages.push(productImage);
      offset += 2 * Math.PI / localProducts.length;
      positionOffset++;
    };

    for (var _iterator = _createForOfIteratorHelperLoose(localProducts), _step; !(_step = _iterator()).done;) {
      _loop();
    }

    return /*#__PURE__*/React.createElement("group", {
      position: position,
      rotation: rotation
    }, productImages);
  }

  var shopifyState;

  if (domain && token) {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    shopifyState = useShopify({
      domain: domain,
      token: token
    });
  } // @ts-ignore


  var _shopifyState = shopifyState,
      products = _shopifyState.products;

  if (products) {
    // @ts-ignore
    products.forEach(function (product) {
      if (product.images[0]) {
        var src = product.images[0].src;
        var productImage = /*#__PURE__*/React.createElement(Image, {
          src: src,
          ratio: itemRatio,
          sizeScale: itemSize,
          position: [spaceBetween * positionOffset, 2, 0],
          rotation: [0, Math.PI, 0],
          framed: true
        });
        productImages.push(productImage);
        positionOffset++;
      }
    });
  }

  return /*#__PURE__*/React.createElement("group", {
    position: position,
    rotation: rotation
  }, productImages);
};

var FONT_FILE = "fonts/Couture_Bold.json";
var Text = function Text(props) {
  var text = props.text,
      _props$vAlign = props.vAlign,
      vAlign = _props$vAlign === void 0 ? "center" : _props$vAlign,
      _props$hAlign = props.hAlign,
      hAlign = _props$hAlign === void 0 ? "center" : _props$hAlign,
      _props$size = props.size,
      size = _props$size === void 0 ? 1 : _props$size,
      _props$bevel = props.bevel,
      bevel = _props$bevel === void 0 ? false : _props$bevel,
      _props$color = props.color,
      color = _props$color === void 0 ? "#000000" : _props$color,
      fontFile = props.font,
      material = props.material,
      restProps = _objectWithoutPropertiesLoose__default['default'](props, ["text", "vAlign", "hAlign", "size", "bevel", "color", "font", "material"]);

  var font = reactThreeFiber.useLoader(THREE.FontLoader, fontFile || FONT_FILE);
  var config = react.useMemo(function () {
    return {
      font: font,
      size: size,
      height: 0.75 * size,
      curveSegments: 32,
      bevelEnabled: bevel,
      bevelThickness: 0.15 * size,
      bevelSize: 0.0625 * size,
      bevelOffset: 0,
      bevelSegments: 8
    };
  }, [font]);
  var mesh = reactThreeFiber.useUpdate(function (self) {
    var size = new THREE.Vector3();
    self.geometry.computeBoundingBox();
    self.geometry.boundingBox.getSize(size);
    self.position.x = hAlign === "center" ? -size.x / 2 : hAlign === "right" ? 0 : -size.x;
    self.position.y = vAlign === "center" ? -size.y / 2 : vAlign === "top" ? 0 : -size.y;
  }, [text]);
  return /*#__PURE__*/React.createElement("group", _extends__default['default']({}, restProps, {
    scale: [0.1 * size, 0.1 * size, 0.1]
  }), /*#__PURE__*/React.createElement("mesh", {
    ref: mesh,
    material: material
  }, /*#__PURE__*/React.createElement("textGeometry", {
    attach: "geometry",
    args: [text, config]
  }), !material && /*#__PURE__*/React.createElement("meshPhongMaterial", {
    attach: "material",
    color: color,
    reflectivity: 30
  })));
};

var frameWidth$1 = 0.3;
var frameDepth$1 = 0.1;
var borderThickness$1 = 0.2;
var borderDepth$1 = 0.2;
var meshOffset$1 = 0.0005;
var Video = function Video(props) {
  var src = props.src,
      sizeScale = props.sizeScale,
      ratio = props.ratio,
      framed = props.framed,
      position = props.position,
      rotation = props.rotation,
      muted = props.muted,
      doubleSided = props.doubleSided;

  var _useThree = reactThreeFiber.useThree(),
      camera = _useThree.camera,
      scene = _useThree.scene;

  var _useEnvironment = useEnvironment(),
      container = _useEnvironment.container,
      paused = _useEnvironment.paused;

  var group = react.useRef(); // video state

  var videoRef = react.useRef();
  var textureRef = react.useRef();

  var _useState = react.useState(false),
      texReady = _useState[0],
      setTexReady = _useState[1]; // audio refs


  var listener = react.useRef();
  var speaker = react.useRef();
  reactThreeFiber.useFrame(function () {
    var _videoRef$current;

    if (!texReady && (videoRef == null ? void 0 : videoRef.current) && (videoRef == null ? void 0 : (_videoRef$current = videoRef.current) == null ? void 0 : _videoRef$current.currentTime) > 0) {
      setTexReady(true);
    }
  });
  var material = react.useMemo(function () {
    return new THREE.MeshStandardMaterial({
      color: 0x111111,
      roughness: 0.8,
      metalness: 0.05
    });
  }, []); // sizing

  var normalizedRatio = new THREE.Vector2(ratio[0], ratio[1]).normalize();
  var width = normalizedRatio.x * sizeScale;
  var height = normalizedRatio.y * sizeScale; // video textures use effect

  react.useEffect(function () {
    if (container && !videoRef.current) {
      // build video dom element
      var video = document.createElement("video");
      var source = document.createElement("source");
      source.src = src;
      video.loop = true; //@ts-ignore

      video.playsInline = true;
      video.crossOrigin = "anonymous";
      video.preload = "auto";
      video.autoplay = false;
      video.muted = muted || false;
      video.style.position = "absolute";
      video.style.opacity = "0";
      video.style.pointerEvents = "none";
      video.style.visibility = "hidden"; // add to parent container

      container.appendChild(video);
      video.appendChild(source); // create video texture

      var texture = new THREE.VideoTexture(video);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.format = THREE.RGBFormat;
      texture.matrixAutoUpdate = false;
      texture.wrapS = THREE.ClampToEdgeWrapping;
      texture.wrapT = THREE.ClampToEdgeWrapping;
      videoRef.current = video;
      textureRef.current = texture;
      return function () {
        video.pause();
        video.remove();
        videoRef.current = undefined;
        texture.dispose();
        textureRef.current = undefined;

        if (speaker.current) {
          speaker.current.disconnect();
          speaker.current = undefined;
        }

        if (listener.current) {
          camera.remove(listener.current);
        }

        setTexReady(false);
      };
    }
  }, [container, videoRef == null ? void 0 : videoRef.current]); // audio useeffect

  react.useEffect(function () {
    if (!muted && !paused && camera && videoRef.current && !speaker.current) {
      listener.current = new THREE.AudioListener();
      camera.add(listener.current);
      speaker.current = new THREE.PositionalAudio(listener.current);
      speaker.current.setMediaElementSource(videoRef.current);
      speaker.current.setRefDistance(0.75);
      speaker.current.setRolloffFactor(1);
      speaker.current.setVolume(1);
      speaker.current.setDirectionalCone(180, 230, 0.1);

      if (position) {
        // @ts-ignore due to bad types, it's an array though
        speaker.current.position.set(position[0], position[1], position[2]);
      }

      if (rotation) {
        // @ts-ignore due to bad types, it's an array though
        speaker.current.rotation.set(rotation[0], rotation[1], rotation[2]);
      }

      scene.add(speaker.current);
    }
  }, [videoRef.current, camera, speaker.current, listener.current, paused]); // play video if player closes menu

  react.useEffect(function () {
    if (!paused && videoRef.current && videoRef.current.paused) {
      videoRef.current.play();
    }
  }, [paused]);
  return /*#__PURE__*/React.createElement("group", props, /*#__PURE__*/React.createElement("group", {
    ref: group
  }, texReady && /*#__PURE__*/React.createElement("mesh", null, /*#__PURE__*/React.createElement("planeBufferGeometry", {
    attach: "geometry",
    args: [width, height]
  }), /*#__PURE__*/React.createElement("meshStandardMaterial", {
    attach: "material",
    map: textureRef.current,
    side: doubleSided ? THREE.DoubleSide : undefined
  })), framed && /*#__PURE__*/React.createElement(React.Fragment, null, !doubleSided && /*#__PURE__*/React.createElement("mesh", {
    "position-z": [-0.1 - meshOffset$1],
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [width + frameWidth$1, height + frameWidth$1, frameDepth$1]
  })), /*#__PURE__*/React.createElement("mesh", {
    "position-y": height / 2 + frameWidth$1 / 2 - borderThickness$1 / 2,
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [width + frameWidth$1, borderThickness$1, borderDepth$1]
  })), /*#__PURE__*/React.createElement("mesh", {
    "position-y": -height / 2 - frameWidth$1 / 2 + borderThickness$1 / 2,
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [width + frameWidth$1, borderThickness$1, borderDepth$1]
  })), /*#__PURE__*/React.createElement("mesh", {
    "position-x": -width / 2 - frameWidth$1 / 2 + borderThickness$1 / 2,
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [borderThickness$1, height + frameWidth$1, borderDepth$1]
  })), /*#__PURE__*/React.createElement("mesh", {
    "position-x": width / 2 + frameWidth$1 / 2 - borderThickness$1 / 2,
    material: material
  }, /*#__PURE__*/React.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [borderThickness$1, height + frameWidth$1, borderDepth$1]
  })))));
};

exports.Arrow = Arrow;
exports.Audio = Audio;
exports.Background = Background;
exports.HDRI = HDRI;
exports.Image = Image;
exports.InfinitePlane = InfinitePlane;
exports.Logo = Logo;
exports.Shop = Shop;
exports.Text = Text;
exports.Video = Video;
import React from "react";