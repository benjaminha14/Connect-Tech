'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));
var React = require('react');
var React__default = _interopDefault(React);
var three = require('three');
var reactThreeFiber = require('react-three-fiber');
var ARButton = require('three/examples/jsm/webxr/ARButton');
var VRButton = require('three/examples/jsm/webxr/VRButton');
var XRControllerModelFactory = require('three/examples/jsm/webxr/XRControllerModelFactory');
var XRHandModelFactory = require('three/examples/jsm/webxr/XRHandModelFactory');

var XRController = {
  make: function make(id, gl, onConnected, onDisconnected) {
    var controller = gl.xr.getController(id);
    var grip = gl.xr.getControllerGrip(id);
    var xrController = {
      inputSource: undefined,
      grip: grip,
      controller: controller,
      hovering: new Set()
    };
    grip.userData.name = 'grip';
    controller.userData.name = 'controller';
    controller.addEventListener('connected', function (event) {
      if (event.fake) {
        return;
      }

      xrController.inputSource = event.data;
      onConnected(xrController);
    });
    controller.addEventListener('disconnected', function (_) {
      onDisconnected(xrController);
    });
  }
};

var XRContext = React.createContext({});

var useControllers = function useControllers() {
  var _useThree = reactThreeFiber.useThree(),
      gl = _useThree.gl,
      scene = _useThree.scene;

  var _React$useState = React.useState([]),
      controllers = _React$useState[0],
      setControllers = _React$useState[1];

  React.useEffect(function () {
    var ids = [0, 1];
    ids.forEach(function (id) {
      XRController.make(id, gl, function (controller) {
        scene.add(controller.controller);
        scene.add(controller.grip);
        setControllers(function (it) {
          return [].concat(it, [controller]);
        });
      }, function (controller) {
        scene.remove(controller.controller);
        scene.remove(controller.grip);
        setControllers(function (existing) {
          return existing.filter(function (it) {
            return it !== controller;
          });
        });
      });
    });
  }, [gl, scene]);
  return controllers;
};

function XR(props) {
  var controllers = useControllers();
  var interactionState = React.useRef({
    interactable: new Set(),
    handlers: {
      onHover: new WeakMap(),
      onBlur: new WeakMap()
    }
  });
  var addInteraction = React.useCallback(function (object, eventType, handler) {
    interactionState.current.interactable.add(object);
    interactionState.current.handlers[eventType].set(object, handler);
  }, []);

  var _React$useState2 = React.useState(function () {
    return new three.Raycaster();
  }),
      raycaster = _React$useState2[0];

  var intersect = React.useCallback(function (controller) {
    var objects = Array.from(interactionState.current.interactable);
    var tempMatrix = new three.Matrix4();
    tempMatrix.identity().extractRotation(controller.matrixWorld);
    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
    return raycaster.intersectObjects(objects, true);
  }, [raycaster]);
  reactThreeFiber.useFrame(function () {
    var handlers = interactionState.current.handlers;

    if (interactionState.current.interactable.size === 0) {
      return;
    }

    controllers.forEach(function (it) {
      var controller = it.controller,
          hovering = it.hovering;
      var hits = new Set();
      var intersections = intersect(controller);
      it.hoverRayLength = undefined;
      intersections.forEach(function (intersection) {
        var eventObject = intersection.object;

        while (eventObject) {
          if (handlers.onHover.has(eventObject)) {
            var _it$hoverRayLength;

            it.hoverRayLength = Math.min((_it$hoverRayLength = it.hoverRayLength) != null ? _it$hoverRayLength : Infinity, intersection.distance);

            if (!hovering.has(eventObject) && handlers.onHover.has(eventObject)) {
              var _handlers$onHover$get;

              hovering.add(eventObject);
              (_handlers$onHover$get = handlers.onHover.get(eventObject)) == null ? void 0 : _handlers$onHover$get({
                controller: it,
                intersection: intersection
              });
            }
          }

          hits.add(eventObject.id);
          eventObject = eventObject.parent;
        }
      });
      hovering.forEach(function (object) {
        if (!hits.has(object.id)) {
          hovering["delete"](object);

          if (handlers.onBlur.has(object)) {
            var _handlers$onBlur$get;

            (_handlers$onBlur$get = handlers.onBlur.get(object)) == null ? void 0 : _handlers$onBlur$get({
              controller: it
            });
          }
        }
      });
    });
  });
  var value = React.useMemo(function () {
    return {
      controllers: controllers,
      addInteraction: addInteraction
    };
  }, [controllers, addInteraction]);
  return /*#__PURE__*/React.createElement(XRContext.Provider, {
    value: value
  }, props.children);
}

function XRCanvas(_ref) {
  var children = _ref.children,
      rest = _objectWithoutPropertiesLoose(_ref, ["children"]);

  return /*#__PURE__*/React.createElement(reactThreeFiber.Canvas, _extends({
    vr: true,
    colorManagement: true
  }, rest), /*#__PURE__*/React.createElement(XR, null, children));
}

function VRCanvas(_ref2) {
  var children = _ref2.children,
      rest = _objectWithoutPropertiesLoose(_ref2, ["children"]);

  return /*#__PURE__*/React.createElement(XRCanvas, _extends({
    onCreated: function onCreated(_ref3) {
      var gl = _ref3.gl;
      return void document.body.appendChild(VRButton.VRButton.createButton(gl));
    }
  }, rest), children);
}
function ARCanvas(_ref4) {
  var children = _ref4.children,
      rest = _objectWithoutPropertiesLoose(_ref4, ["children"]);

  return /*#__PURE__*/React.createElement(XRCanvas, _extends({
    onCreated: function onCreated(_ref5) {
      var gl = _ref5.gl;
      return void document.body.appendChild(ARButton.ARButton.createButton(gl));
    }
  }, rest), children);
}
var useXR = function useXR() {
  return React.useContext(XRContext);
};
var useController = function useController(handedness) {
  var _useXR = useXR(),
      controllers = _useXR.controllers;

  var controller = React.useMemo(function () {
    return controllers.find(function (it) {
      return it.inputSource.handedness === handedness;
    });
  }, [handedness, controllers]);
  return controller;
};
var useXREvent = function useXREvent(event, handler, _temp) {
  var _ref6 = _temp === void 0 ? {} : _temp,
      handedness = _ref6.handedness;

  var _useXR2 = useXR(),
      allControllers = _useXR2.controllers;

  var handleEvent = React.useCallback(function (controller) {
    return function (e) {
      return handler({
        originalEvent: e,
        controller: controller
      });
    };
  }, [handler]);
  React.useEffect(function () {
    var controllers = handedness ? allControllers.filter(function (it) {
      return it.inputSource.handedness === handedness;
    }) : allControllers;
    var cleanups = [];
    controllers.forEach(function (it) {
      var listener = handleEvent(it);
      it.controller.addEventListener(event, listener);
      cleanups.push(function () {
        return it.controller.removeEventListener(event, listener);
      });
    });
    return function () {
      return cleanups.forEach(function (fn) {
        return fn();
      });
    };
  }, [event, handleEvent, allControllers, handedness]);
};

function Hover(_ref) {
  var onChange = _ref.onChange,
      children = _ref.children;
  var ref = React.useRef();

  var _useXR = useXR(),
      addInteraction = _useXR.addInteraction;

  var hovering = React.useRef(new Set());
  React.useEffect(function () {
    addInteraction(ref.current, 'onHover', function (e) {
      var _e$controller$inputSo;

      if (hovering.current.size === 0) {
        onChange(true);
      }

      hovering.current.add((_e$controller$inputSo = e.controller.inputSource) == null ? void 0 : _e$controller$inputSo.handedness);
    });
    addInteraction(ref.current, 'onBlur', function (e) {
      var _e$controller$inputSo2;

      hovering.current["delete"]((_e$controller$inputSo2 = e.controller.inputSource) == null ? void 0 : _e$controller$inputSo2.handedness);

      if (hovering.current.size === 0) {
        onChange(false);
      }
    });
  }, [onChange, addInteraction]);
  return /*#__PURE__*/React__default.createElement("group", {
    ref: ref
  }, children);
}
function Select(_ref2) {
  var onSelect = _ref2.onSelect,
      children = _ref2.children;
  var ref = React.useRef();

  var _useXR2 = useXR(),
      addInteraction = _useXR2.addInteraction;

  var hoveredHandedness = React.useRef(new Set());
  var onEnd = React.useCallback(function (e) {
    var _e$controller$inputSo3;

    if (hoveredHandedness.current.has((_e$controller$inputSo3 = e.controller.inputSource) == null ? void 0 : _e$controller$inputSo3.handedness)) {
      onSelect();
    }
  }, [onSelect]);
  useXREvent('selectend', onEnd);
  React.useEffect(function () {
    addInteraction(ref.current, 'onHover', function (e) {
      var _e$controller$inputSo4;

      hoveredHandedness.current.add((_e$controller$inputSo4 = e.controller.inputSource) == null ? void 0 : _e$controller$inputSo4.handedness);
    });
    addInteraction(ref.current, 'onBlur', function (e) {
      var _e$controller$inputSo5;

      hoveredHandedness.current["delete"]((_e$controller$inputSo5 = e.controller.inputSource) == null ? void 0 : _e$controller$inputSo5.handedness);
    });
  }, [addInteraction]);
  return /*#__PURE__*/React__default.createElement("group", {
    ref: ref
  }, children);
}
function RayGrab(_ref3) {
  var children = _ref3.children;

  var _useXR3 = useXR(),
      addInteraction = _useXR3.addInteraction;

  var hoveredHandedness = React.useRef(new Set());
  var grabbingController = React.useRef();
  var groupRef = React.useRef();
  var previousTransform = React.useRef(undefined);
  var onEnd = React.useCallback(function (_) {
    grabbingController.current = undefined;
    previousTransform.current = undefined;
  }, []);
  var onStart = React.useCallback(function (e) {
    if (hoveredHandedness.current.has(e.controller.inputSource.handedness)) {
      grabbingController.current = e.controller.controller;
      previousTransform.current = new three.Matrix4().getInverse(e.controller.controller.matrixWorld);
    }
  }, []);
  useXREvent('selectstart', onStart);
  useXREvent('selectend', onEnd);
  reactThreeFiber.useFrame(function () {
    if (!grabbingController.current || !previousTransform.current || !groupRef.current) {
      return;
    }

    var controller = grabbingController.current;
    var group = groupRef.current;
    group.applyMatrix4(previousTransform.current);
    group.applyMatrix4(controller.matrixWorld);
    group.updateWorldMatrix(false, true);
    previousTransform.current.getInverse(controller.matrixWorld);
  });
  React.useEffect(function () {
    addInteraction(groupRef.current, 'onHover', function (e) {
      hoveredHandedness.current.add(e.controller.inputSource.handedness);
    });
    addInteraction(groupRef.current, 'onBlur', function (e) {
      hoveredHandedness.current["delete"](e.controller.inputSource.handedness);
    });
  }, [addInteraction]);
  return /*#__PURE__*/React__default.createElement("group", {
    ref: groupRef
  }, children);
}

var modelFactory = new XRControllerModelFactory.XRControllerModelFactory();
function DefaultXRControllers() {
  var _useThree = reactThreeFiber.useThree(),
      scene = _useThree.scene;

  var _useXR = useXR(),
      controllers = _useXR.controllers;

  var _React$useState = React__default.useState(new Map()),
      rays = _React$useState[0]; // Show ray line when hovering objects


  reactThreeFiber.useFrame(function () {
    controllers.forEach(function (it) {
      var ray = rays.get(it.controller.id);

      if (!ray) {
        return;
      }

      if (it.hoverRayLength === undefined || it.inputSource.handedness === 'none') {
        ray.visible = false;
        return;
      } // Tiny offset to clip ray on AR devices
      // that don't have handedness set to 'none'


      var offset = -0.01;
      ray.visible = true;
      ray.scale.y = it.hoverRayLength + offset;
      ray.position.z = -it.hoverRayLength / 2 - offset;
    });
  });
  useXREvent('selectstart', function (e) {
    var ray = rays.get(e.controller.controller.id);

    if (!ray) {
      return;
    }

    var material = ray.material;
    material.color = new three.Color(0x192975);
  });
  useXREvent('selectend', function (e) {
    var ray = rays.get(e.controller.controller.id);

    if (!ray) {
      return;
    }

    var material = ray.material;
    material.color = new three.Color(0xffffff);
  });
  React.useEffect(function () {
    var cleanups = [];
    controllers.forEach(function (_ref) {
      var controller = _ref.controller,
          grip = _ref.grip,
          inputSource = _ref.inputSource;
      // Attach 3D model of the controller
      var model = modelFactory.createControllerModel(controller);
      controller.dispatchEvent({
        type: 'connected',
        data: inputSource,
        fake: true
      });
      grip.add(model); // Add Ray line (used for hovering)

      var ray = new three.Mesh();
      ray.rotation.set(Math.PI / 2, 0, 0);
      ray.material = new three.MeshBasicMaterial({
        color: new three.Color(0xffffff),
        opacity: 0.8,
        transparent: true
      });
      ray.geometry = new three.BoxBufferGeometry(0.002, 1, 0.002);
      rays.set(controller.id, ray);
      controller.add(ray);
      cleanups.push(function () {
        grip.remove(model);
        controller.remove(ray);
      });
    });
    return function () {
      cleanups.forEach(function (fn) {
        return fn();
      });
    };
  }, [controllers, scene, rays]);
  return null;
}

function Hands(_ref) {
  var _ref$profile = _ref.profile,
      profile = _ref$profile === void 0 ? 'oculus' : _ref$profile;

  var _useThree = reactThreeFiber.useThree(),
      scene = _useThree.scene,
      gl = _useThree.gl;

  React.useEffect(function () {
    var handFactory = new XRHandModelFactory.XRHandModelFactory().setPath('https://threejs.org/examples/models/fbx/');
    var options = profile === 'oculus_lowpoly' ? {
      model: 'lowpoly'
    } : undefined;
    var threeProfile = profile === 'oculus_lowpoly' ? 'oculus' : profile; // @ts-ignore

    var hand1 = gl.xr.getHand(0);
    scene.add(hand1);
    hand1.add(handFactory.createHandModel(hand1, threeProfile, options)); // @ts-ignore

    var hand2 = gl.xr.getHand(1);
    scene.add(hand2);
    hand2.add(handFactory.createHandModel(hand2, threeProfile, options));
  }, [scene, gl]);
  return null;
}

exports.ARCanvas = ARCanvas;
exports.DefaultXRControllers = DefaultXRControllers;
exports.Hands = Hands;
exports.Hover = Hover;
exports.RayGrab = RayGrab;
exports.Select = Select;
exports.VRCanvas = VRCanvas;
exports.XR = XR;
exports.XRController = XRController;
exports.useController = useController;
exports.useXR = useXR;
exports.useXREvent = useXREvent;
