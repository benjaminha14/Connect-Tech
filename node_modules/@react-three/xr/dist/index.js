import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
import React__default, { createContext, useRef, useCallback, useState, useMemo, createElement, useContext, useEffect } from 'react';
import { Raycaster, Matrix4, Color, Mesh, MeshBasicMaterial, BoxBufferGeometry } from 'three';
import { useFrame, useThree, Canvas } from 'react-three-fiber';
import { ARButton } from 'three/examples/jsm/webxr/ARButton';
import { VRButton } from 'three/examples/jsm/webxr/VRButton';
import { XRControllerModelFactory } from 'three/examples/jsm/webxr/XRControllerModelFactory';
import { XRHandModelFactory } from 'three/examples/jsm/webxr/XRHandModelFactory';

const XRController = {
  make: (id, gl, onConnected, onDisconnected) => {
    const controller = gl.xr.getController(id);
    const grip = gl.xr.getControllerGrip(id);
    const xrController = {
      inputSource: undefined,
      grip,
      controller,
      hovering: new Set()
    };
    grip.userData.name = 'grip';
    controller.userData.name = 'controller';
    controller.addEventListener('connected', event => {
      if (event.fake) {
        return;
      }

      xrController.inputSource = event.data;
      onConnected(xrController);
    });
    controller.addEventListener('disconnected', _ => {
      onDisconnected(xrController);
    });
  }
};

const XRContext = createContext({});

const useControllers = () => {
  const {
    gl,
    scene
  } = useThree();
  const [controllers, setControllers] = useState([]);
  useEffect(() => {
    const ids = [0, 1];
    ids.forEach(id => {
      XRController.make(id, gl, controller => {
        scene.add(controller.controller);
        scene.add(controller.grip);
        setControllers(it => [...it, controller]);
      }, controller => {
        scene.remove(controller.controller);
        scene.remove(controller.grip);
        setControllers(existing => existing.filter(it => it !== controller));
      });
    });
  }, [gl, scene]);
  return controllers;
};

function XR(props) {
  const controllers = useControllers();
  const interactionState = useRef({
    interactable: new Set(),
    handlers: {
      onHover: new WeakMap(),
      onBlur: new WeakMap()
    }
  });
  const addInteraction = useCallback((object, eventType, handler) => {
    interactionState.current.interactable.add(object);
    interactionState.current.handlers[eventType].set(object, handler);
  }, []);
  const [raycaster] = useState(() => new Raycaster());
  const intersect = useCallback(controller => {
    const objects = Array.from(interactionState.current.interactable);
    const tempMatrix = new Matrix4();
    tempMatrix.identity().extractRotation(controller.matrixWorld);
    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
    return raycaster.intersectObjects(objects, true);
  }, [raycaster]);
  useFrame(() => {
    const {
      handlers
    } = interactionState.current;

    if (interactionState.current.interactable.size === 0) {
      return;
    }

    controllers.forEach(it => {
      const {
        controller,
        hovering
      } = it;
      const hits = new Set();
      const intersections = intersect(controller);
      it.hoverRayLength = undefined;
      intersections.forEach(intersection => {
        let eventObject = intersection.object;

        while (eventObject) {
          if (handlers.onHover.has(eventObject)) {
            var _it$hoverRayLength;

            it.hoverRayLength = Math.min((_it$hoverRayLength = it.hoverRayLength) != null ? _it$hoverRayLength : Infinity, intersection.distance);

            if (!hovering.has(eventObject) && handlers.onHover.has(eventObject)) {
              var _handlers$onHover$get;

              hovering.add(eventObject);
              (_handlers$onHover$get = handlers.onHover.get(eventObject)) == null ? void 0 : _handlers$onHover$get({
                controller: it,
                intersection
              });
            }
          }

          hits.add(eventObject.id);
          eventObject = eventObject.parent;
        }
      });
      hovering.forEach(object => {
        if (!hits.has(object.id)) {
          hovering.delete(object);

          if (handlers.onBlur.has(object)) {
            var _handlers$onBlur$get;

            (_handlers$onBlur$get = handlers.onBlur.get(object)) == null ? void 0 : _handlers$onBlur$get({
              controller: it
            });
          }
        }
      });
    });
  });
  const value = useMemo(() => ({
    controllers,
    addInteraction
  }), [controllers, addInteraction]);
  return /*#__PURE__*/createElement(XRContext.Provider, {
    value: value
  }, props.children);
}

function XRCanvas(_ref) {
  let {
    children
  } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, ["children"]);

  return /*#__PURE__*/createElement(Canvas, _extends({
    vr: true,
    colorManagement: true
  }, rest), /*#__PURE__*/createElement(XR, null, children));
}

function VRCanvas(_ref2) {
  let {
    children
  } = _ref2,
      rest = _objectWithoutPropertiesLoose(_ref2, ["children"]);

  return /*#__PURE__*/createElement(XRCanvas, _extends({
    onCreated: ({
      gl
    }) => void document.body.appendChild(VRButton.createButton(gl))
  }, rest), children);
}
function ARCanvas(_ref3) {
  let {
    children
  } = _ref3,
      rest = _objectWithoutPropertiesLoose(_ref3, ["children"]);

  return /*#__PURE__*/createElement(XRCanvas, _extends({
    onCreated: ({
      gl
    }) => void document.body.appendChild(ARButton.createButton(gl))
  }, rest), children);
}
const useXR = () => useContext(XRContext);
const useController = handedness => {
  const {
    controllers
  } = useXR();
  const controller = useMemo(() => controllers.find(it => it.inputSource.handedness === handedness), [handedness, controllers]);
  return controller;
};
const useXREvent = (event, handler, {
  handedness
} = {}) => {
  const {
    controllers: allControllers
  } = useXR();
  const handleEvent = useCallback(controller => e => handler({
    originalEvent: e,
    controller
  }), [handler]);
  useEffect(() => {
    const controllers = handedness ? allControllers.filter(it => it.inputSource.handedness === handedness) : allControllers;
    const cleanups = [];
    controllers.forEach(it => {
      const listener = handleEvent(it);
      it.controller.addEventListener(event, listener);
      cleanups.push(() => it.controller.removeEventListener(event, listener));
    });
    return () => cleanups.forEach(fn => fn());
  }, [event, handleEvent, allControllers, handedness]);
};

function Hover({
  onChange,
  children
}) {
  const ref = useRef();
  const {
    addInteraction
  } = useXR();
  const hovering = useRef(new Set());
  useEffect(() => {
    addInteraction(ref.current, 'onHover', e => {
      var _e$controller$inputSo;

      if (hovering.current.size === 0) {
        onChange(true);
      }

      hovering.current.add((_e$controller$inputSo = e.controller.inputSource) == null ? void 0 : _e$controller$inputSo.handedness);
    });
    addInteraction(ref.current, 'onBlur', e => {
      var _e$controller$inputSo2;

      hovering.current.delete((_e$controller$inputSo2 = e.controller.inputSource) == null ? void 0 : _e$controller$inputSo2.handedness);

      if (hovering.current.size === 0) {
        onChange(false);
      }
    });
  }, [onChange, addInteraction]);
  return /*#__PURE__*/React__default.createElement("group", {
    ref: ref
  }, children);
}
function Select({
  onSelect,
  children
}) {
  const ref = useRef();
  const {
    addInteraction
  } = useXR();
  const hoveredHandedness = useRef(new Set());
  const onEnd = useCallback(e => {
    var _e$controller$inputSo3;

    if (hoveredHandedness.current.has((_e$controller$inputSo3 = e.controller.inputSource) == null ? void 0 : _e$controller$inputSo3.handedness)) {
      onSelect();
    }
  }, [onSelect]);
  useXREvent('selectend', onEnd);
  useEffect(() => {
    addInteraction(ref.current, 'onHover', e => {
      var _e$controller$inputSo4;

      hoveredHandedness.current.add((_e$controller$inputSo4 = e.controller.inputSource) == null ? void 0 : _e$controller$inputSo4.handedness);
    });
    addInteraction(ref.current, 'onBlur', e => {
      var _e$controller$inputSo5;

      hoveredHandedness.current.delete((_e$controller$inputSo5 = e.controller.inputSource) == null ? void 0 : _e$controller$inputSo5.handedness);
    });
  }, [addInteraction]);
  return /*#__PURE__*/React__default.createElement("group", {
    ref: ref
  }, children);
}
function RayGrab({
  children
}) {
  const {
    addInteraction
  } = useXR();
  const hoveredHandedness = useRef(new Set());
  const grabbingController = useRef();
  const groupRef = useRef();
  const previousTransform = useRef(undefined);
  const onEnd = useCallback(_ => {
    grabbingController.current = undefined;
    previousTransform.current = undefined;
  }, []);
  const onStart = useCallback(e => {
    if (hoveredHandedness.current.has(e.controller.inputSource.handedness)) {
      grabbingController.current = e.controller.controller;
      previousTransform.current = new Matrix4().getInverse(e.controller.controller.matrixWorld);
    }
  }, []);
  useXREvent('selectstart', onStart);
  useXREvent('selectend', onEnd);
  useFrame(() => {
    if (!grabbingController.current || !previousTransform.current || !groupRef.current) {
      return;
    }

    const controller = grabbingController.current;
    const group = groupRef.current;
    group.applyMatrix4(previousTransform.current);
    group.applyMatrix4(controller.matrixWorld);
    group.updateWorldMatrix(false, true);
    previousTransform.current.getInverse(controller.matrixWorld);
  });
  useEffect(() => {
    addInteraction(groupRef.current, 'onHover', e => {
      hoveredHandedness.current.add(e.controller.inputSource.handedness);
    });
    addInteraction(groupRef.current, 'onBlur', e => {
      hoveredHandedness.current.delete(e.controller.inputSource.handedness);
    });
  }, [addInteraction]);
  return /*#__PURE__*/React__default.createElement("group", {
    ref: groupRef
  }, children);
}

const modelFactory = new XRControllerModelFactory();
function DefaultXRControllers() {
  const {
    scene
  } = useThree();
  const {
    controllers
  } = useXR();
  const [rays] = React__default.useState(new Map()); // Show ray line when hovering objects

  useFrame(() => {
    controllers.forEach(it => {
      const ray = rays.get(it.controller.id);

      if (!ray) {
        return;
      }

      if (it.hoverRayLength === undefined || it.inputSource.handedness === 'none') {
        ray.visible = false;
        return;
      } // Tiny offset to clip ray on AR devices
      // that don't have handedness set to 'none'


      const offset = -0.01;
      ray.visible = true;
      ray.scale.y = it.hoverRayLength + offset;
      ray.position.z = -it.hoverRayLength / 2 - offset;
    });
  });
  useXREvent('selectstart', e => {
    const ray = rays.get(e.controller.controller.id);

    if (!ray) {
      return;
    }

    const material = ray.material;
    material.color = new Color(0x192975);
  });
  useXREvent('selectend', e => {
    const ray = rays.get(e.controller.controller.id);

    if (!ray) {
      return;
    }

    const material = ray.material;
    material.color = new Color(0xffffff);
  });
  useEffect(() => {
    const cleanups = [];
    controllers.forEach(({
      controller,
      grip,
      inputSource
    }) => {
      // Attach 3D model of the controller
      const model = modelFactory.createControllerModel(controller);
      controller.dispatchEvent({
        type: 'connected',
        data: inputSource,
        fake: true
      });
      grip.add(model); // Add Ray line (used for hovering)

      const ray = new Mesh();
      ray.rotation.set(Math.PI / 2, 0, 0);
      ray.material = new MeshBasicMaterial({
        color: new Color(0xffffff),
        opacity: 0.8,
        transparent: true
      });
      ray.geometry = new BoxBufferGeometry(0.002, 1, 0.002);
      rays.set(controller.id, ray);
      controller.add(ray);
      cleanups.push(() => {
        grip.remove(model);
        controller.remove(ray);
      });
    });
    return () => {
      cleanups.forEach(fn => fn());
    };
  }, [controllers, scene, rays]);
  return null;
}

function Hands({
  profile = 'oculus'
}) {
  const {
    scene,
    gl
  } = useThree();
  useEffect(() => {
    const handFactory = new XRHandModelFactory().setPath('https://threejs.org/examples/models/fbx/');
    const options = profile === 'oculus_lowpoly' ? {
      model: 'lowpoly'
    } : undefined;
    const threeProfile = profile === 'oculus_lowpoly' ? 'oculus' : profile; // @ts-ignore

    const hand1 = gl.xr.getHand(0);
    scene.add(hand1);
    hand1.add(handFactory.createHandModel(hand1, threeProfile, options)); // @ts-ignore

    const hand2 = gl.xr.getHand(1);
    scene.add(hand2);
    hand2.add(handFactory.createHandModel(hand2, threeProfile, options));
  }, [scene, gl]);
  return null;
}

export { ARCanvas, DefaultXRControllers, Hands, Hover, RayGrab, Select, VRCanvas, XR, XRController, useController, useXR, useXREvent };
